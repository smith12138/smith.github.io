{"meta":{"title":"清风明月","subtitle":"","description":"","author":"MingHui","url":"http://yoursite.com","root":"/"},"posts":[{"tags":[{"name":"InterFace Test","slug":"InterFace-Test","permalink":"http://yoursite.com/tags/InterFace-Test/"}],"title":"interface_test_basic","date":"2020/07/07","text":"为什么要做接口测试？ 在日常前后端开发中，他们之间为什么是独立完成的？ 接口的由来：连接前后端，以及移动端 不同端的工作进度不一样，需要对最开始出来的接口，进行接口测试 接口测试带来了哪些好处？ 比如调用第三方的接口，淘宝，银行，支付宝…，那么我们就要进行接口测试，以及验证数据 节约时间，缩短项目时间 提高工作效率 提高系统的稳定性 什么是接口？ http请求 -&gt; 接口 ，不断地操作系统 -&gt; 系统不断的去服务端，第三方服务调用接口 接口的种类 内部接口 外部接口 我们测试的接口，接收测试http，tcp请求 Get，Post请求是日常中，使用较多的接口类型 Get，Post的区别 理论上GET请求数据长度没有限制的，真正起到限制的是浏览器对其长度进行了限制。 POST请求理论上也是不限制大小的，真正对其大小进行限制的是服务器的处理程序能力 参数提交方式 Post请求的数据是WebForm里面的，以表单的形式提交 Get请求的数据是在地址栏中，进行请求的 接口地址以？分隔开，后面就是数据，以&amp;连接符连接 请求数据大小 Get请求的数据相比Post是较少的 GET请求的URL长度根据不同的浏览器，会有不同的字节限制 Browser Length IE URL &lt;= 2083 Path &lt;= 2048 Firefox 65536 Safari 80000以上 Opera 190000以上 超出最大抓取/索引字节长度 会报414 Chrome 8182 Apache Sever 8192 iis 16384 Perl Http:Daemon 至少8000 安全性 Get请求的用户信息在URL栏中，安全性相比Post表单请求，安全性低 接口测试流程 一个简单的事情，需要认真，有条理的去执行 可能当时没有出错，谁又能保证以后不出错，尽量做好万全的准备 熟悉接口测试流程的好处： 以备面试所需 熟悉接下来的流程 掌握基础知识 面试时，通常基础知识问答较多 测试流程的重点：设计用例 理清思路，避免漏测（不可进行随机测试） 提高测试效率 跟进测试进度 证明进行过测试（一种凭证） 跟进重复性工作 黑盒：需求文档 接口测试：需要开发提供的API文档 接口测试用例设计 接口测试工具 提高工作效率，不管是否上线 使用工具的目的 举例： 10分钟测试10个get接口，使用不熟悉的loadrunner录制脚本，对接口进行参数化，然后查看日志结果。此时就不宜使用臃肿的测试工具 如何选择接口测试工具 时间，简易程度，业务复杂度，测试员能力 接口测试工具分类 Tools Purpose Httpwatch HTTP 仅支持IE，firefox浏览器，看数据比较麻烦 Wireshark TCP/HTTP 功能齐全，经过PC端的请求http/tcp，都能抓取到，所以数据量大，查看比较麻烦 Fiddler HTTP 可直接抓取http请求，小巧，功能完善，启动快捷，代理方便 测试接口 Loadrunner 第一印象：是一个性能测试工具 功能强大，可以进行接口测试 所有性能测试都是基于http请求的 把接口按照http请求的格式，进行测试 通过两个函数 Fidder 轻量级抓包兼测试工具 SoapUI 比较强大的测试工具，可以做接口，也可以做自动化 功能也比较齐全，返回的乱码可进行转换，打开接口文档对比 Jmeter 不仅仅是性能测试，可以使用http请求进行接口测试 Postman 测试中常用选择 接口测试工具-三剑客 Postman 导入body中的数据一定要仔细核对 如何自动反复测试带header的Post请求，并且针对线上，测试环境同一个数据进行测试。并对实际结果作比较，作为测试结果 各种类型接口测试 按需求添加cookie，header 操作记录清晰 多接口同时测试 方便回归 提高技能水平 Fiddler 简介： 是一款http协议代理调试工具，能够记录并检查电脑与互联网之间所有的http协议，设置断点，查看所有”进出”Fiddler的数据 工作原理： 运用步骤： 查看接口请求方式 查看请求数据，响应数据 接口返回状态 设置代理（抓取移动端接口请求） 查看header，cookie 设置断点 添加筛选 接口测试 Python自开发 工具没法满足需求时 安全性 业务限制 逻辑清晰-&gt;表达，理解能力强-&gt;看懂代码-&gt;会写代码-&gt;会改代码 测试流程 通过urllib urllib2 扩展库 定义接口地址 定义请求数据 整理请求数据 按照格式拼接，按照规定格式发送server 发送数据并获取返回结果","permalink":"http://yoursite.com/2020/07/07/Python/interface/interface_test_basic/","photos":[]},{"tags":[{"name":"Automation InterFace Test","slug":"Automation-InterFace-Test","permalink":"http://yoursite.com/tags/Automation-InterFace-Test/"}],"title":"interface_automation","date":"2020/07/07","text":"导语合格的自动化测试工程师 -&gt; 接口自动化测试框架 入门条件 -&gt; 设计-开发-重构框架 进阶之路：接口基础 -&gt; 接口开发 -&gt; Unittest与接口测试结合 -&gt; 设计，开发框架 接口基础 HTTP接口熟悉 常见接口介绍 接口工具的使用 接口测试基础的面试 接口开发 使用Django，开发Get，Post请求 掌握Unittest与接口测试的结合 Unittest使用，断言，HTMLTestRunner，Case的管理，Request的引入使用 接口自动化测试框架从设计到开发 设计框架 根据框架，设计工具封装 基类封装 Debug 数据处理 回写测试结果 解决数据依赖 结果统计 邮件服务 发送报告 常见接口测试查缺补漏 操作数据库 操作cookie 接口基础面试 如何理解接口？ 前后端解耦，需要一个桥梁，负责前后端传输数据 接口测试和功能测试的区别 是功能测试的一种，功能测试的定义非常广泛 自动化属于功能测试，无论是接口还是自动化测试，都是模拟用户的操作 接口测试只是模拟用户发送数据，只是没有经过前端/客户端 自动化模拟用户操作，减去了手工操作，通过脚本去实现 在国内来说，技术能力可能会比功能测试好-含金量不同 常见的接口类型 Post，get，put，delete 接口是如何传递参数 Get请求?前方为URL地址，后方为消息主体/请求数据 Post请求是以WebFrom/表单的形式提交数据 如何测试一个接口？ Fiddler Postman soapUI Loadrunner Jmeter 工具只是一种实现方式而已 怎么简单怎么做（主要是效率） 模拟请求(1) 为什么模拟请求 ① 解耦很重要 ② 并行开发很重要（效率第一） ③ 使用Fiddler模拟请求 1) 进入Composer工具栏，传入对应headers，body ④ 使用fiddler模拟响应 1) 进入AutoResponder工具栏，传入对应url，以及对应的response数据 \\6. 搭建Django框架-测试环境—工程项目 (1) 开发web端是比较实用的 (2) 安装Django框架 ① 在线安装：pip install Django ==指定版本 ② 离线安装：python setup.py install 1) 官网下载所需版本 2) 解压，然后在cmd中，进入存放目录，输入命令 (3) 在终端输入命令：django-admin startproject HelloWorld（项目名可修改） ① 外部HelloWorld/根目录是您的项目的容器。它的名字对Django无关紧要。您可以将其重命名为您喜欢的任何名称。 ② manage.py：一个命令行实用程序，可让您以各种方式与该Django项目进行交互。您可以manage.py在django-admin和manage.py中阅读有关的所有详细信息 。 ③ 内部HelloWorld/目录是项目的实际Python包。它的名称是Python包名称，您需要使用它来导入其中的任何内容（例如HelloWorld.urls）。 ④ HelloWorld/init.py：一个空文件，告诉Python该目录应视为Python软件包。如果您是Python初学者，请在Python官方文档中阅读有关包的更多信息。 ⑤ HelloWorld/settings.py：此Django项目的设置/配置。 Django设置将告诉您所有设置的工作方式。 ⑥ HelloWorld/urls.py：此Django项目的URL声明；Django支持的网站的“目录”。您可以在URL调度程序中阅读有关URL的更多信息。 ⑦ HelloWorld/asgi.py：与ASGI兼容的Web服务器为您的项目提供服务的入口点。有关更多详细信息，请参见如何使用ASGI进行部署。 ⑧ HelloWorld/wsgi.py：与WSGI兼容的Web服务器为您的项目提供服务的入口点。有关更多详细信息，请参见如何使用WSGI进行部署 (4) 运行django ① 在根目录下，在终端中运行：python manage.py runserver 127.0.0.1:8000 ② 在browser中，输入127.0.0.1:8000 \\7. 创建工程应用app (1) 创建新的app，使用系统模块manage ① 回到根目录，进入终端：python manage.py startapp name (2) 原理 ① 需要知道地址怎么到server的，访问urls.py中的方法，执行urlpatterns中的方法 ② 创建的app中的views.py模块中，定义方法 ③ 在urls.py模块中，引入login方法，urlpatterns变量中，调用login方法 \\1. 用户在敲下你的网址并回车，生成请求 \\2. 请求传递到urls.py；Django去urlpatterns中匹配链接（Django会在匹配到的第一个就停下来） \\3. 一旦匹配成功，Django便会给出相应的view页面（该页面可以为一个Python的函数，或者基于view（Django内置的）的类），也就是用户看到的页面 \\4. 若匹配失败，则出现错误的页面 \\5. 一个工程项目，有很多个APP，每个APP都是工程组成的一部分 \\8. 开发接口 (1) 框架 ① 都是基于代码 ② 框架就是把所有的代码进行整合，写的简洁一些，逻辑是没有改变的 ③ 无非是多个中间服务商，Apache，Nginx之类的 ④ 只需要知道url跳转到哪儿，在哪儿解析，Response什么信息 ⑤ 真正的API在views模块里面 ⑥ 注意事项： 1) 代理端口需区分，否则会冲突 2) HTML中form表单，与from区分 3) HTML中路径需以/斜杠结尾 \\9. Unittest (1) 创建一个类的时候，继承Unittest框架中TestCase类 (2) 内置方法 ① setUp：每次方法之前执行 ② tearDown：每次方法之后执行 ③ sefUpClass：类执行前执行 ④ tearDownClass：类执行后执行 ⑤ Test_XX：单词在前的case方法，缺少test则不会运行 (3) 断言–assert ① assertEqual：x == y ？None : z ② assertNotEqual：x != y ？None : z ③ assertTrue：type(x) == True ? None : z (4) 全局变量 ① 相比类变量更加快捷 ② 命名方式：Globals()[‘变量名’] 解决依赖 (5) 跳过case执行： ① 使用语法糖：@ unittest.skip(‘case’) (6) 创建容器 ① 创建语法：Suite = unittest.TestSuite() ② 添加case：Suite.addTest(类名(casename)) ③ 可添加多个case ④ 执行容器：unittest.TextTestRunner().run(容器名) (7) 结合HTMLTestRunner，生成TestReport ① Google-&gt;Python3 HTMLTestRunner，最好是GitHub上面的 ② 创建HTMLTestRunner.py，移至Python-&gt;lib目录 ③ 在case文件中，引入HTMLTestRunner模块 (8) Unittest之面试 ① 如何使用Python开发测试框架 1) 语言：Python 2) 接口：使用requests第三方库 3) 管理case：unittest框架-断言-skipcase-suite容器-依赖关系 4) 报告：HTMLTestRunner 5) 数据管理：Excel，MySql 6) Case执行：持续集成或批处理文件 (9) 建议 ① Unittest中，case是按照ascll码比较，进行升序执行 ② 尽量减少依赖执行 ③ GET请求URL与Data分离传参，无响应 ④ Globals()[‘变量’] = data 下个case调用会报错 \\10. Mock服务 (1) 以代码来实现自动响应请求的功能，模拟返回数据 (2) 引入mock ① Import unittest.mock (3) 使用方法 ① mock_name = mock.Mock(return_value=模拟数据) ② 请求方法 = mock_name(改变返回模拟数据) ③ 示例： ​ mock_data = mock.Mock(return_value=response_data) ​ method = mock_data ​ res = method(request_data, url, method) (4) 重构封装mock ① 示例： # 封装mock-method from unittest import mock def mock_test(mock_method, url, method, request_data=None, response_data=None): if response_data == None: ​ res = mock_method(url, method, response_data) ​ return res else: ​ mock_data = mock.Mock(return_value=response_data) ​ mock_method = mock_data ​ res = mock_method(request_data, url, method) ​ return res \\11. 设计接口自动化测试框架 (1) Case过多，避免繁琐操作 (2) 不排除某些需求，设定特殊的值，而手动添加 (3) 编写接口测试用例 ① (4) 需要考虑的点 ① 接口地址 ② 请求数据 ③ 接口类型 ④ 预期结果 ⑤ Header - cookie ⑥ 数据依赖–接口自动化的难点 (5) 操作Excel ① 定义一个类 ② ③ 重构封装excel函数 1) 封装request_data, header 2) 封装调用类 ④ 封装request类 ⑤ 对response_data，进行格式化 1) Json.dumps(response, ensure_ascii=False, intent=2, sort_keys=True) 2) 使用ensure_ascii的注意事项： a. json_dumps(dict)时，如果dict包含有汉字，一定加上ensure_ascii=False。否则按参数默认值True，意思是保证dumps之后的结果里所有的字符都能够被ascii表示，汉字在ascii的字符集里面，因此经过dumps以后的str里，汉字会变成对应的unicode。 \\12. 写入excel测试结果 (1) 判断接口返回状态 ① 接口是否通畅 1) 调用status_code方法 \\13. 引入jsonpath_rw 第三方库 (1) 从第三方库中引入jsonpath，parse 方法 ① B = {‘foo’: [{‘baz’: ‘news’}, {‘baz’: ‘music’}]} (2) 赋予规则 ① A = parse(‘foo[*].data’) (3) 解析数据 ① C = A.find(b) (4) 使用列表推导式，获取数据 ① Data = [match.value for match in C][0] index get content \\14.","permalink":"http://yoursite.com/2020/07/07/Python/interface/interface_automation/","photos":[]},{"tags":[{"name":"Basics","slug":"Basics","permalink":"http://yoursite.com/tags/Basics/"}],"title":"basic","date":"2020/06/30","text":"一．Git基础1．Git介绍 Git是目前世界上最先进的分布式版本控制系统 版本控制系统： 记录每个迭代版本的信息 版本号 文件名 操作用户 日志 修改时间 1 Test.py well 修改标题 2020/04/18/17:15 2 Test.py jack 优化性能 2020/04/18/18:00 3 Test.py esion 修复bug 2020/04/18/19:15 4 Test.py jack 功能更新 2020/04/18/20:15 2．Git与Github2.1.两者区别 Git 是一个分布式版本控制系统，简单来说它就是一个软件，用于记录一个或多干个文件迭代信息，以便将来查阅某个版本修订情况的软件 Github 是一个为用户提供Git服务的网站，简单说就是一个可以存放代码的地方，也可以是其他东西，Github除了提供管理Git的Web界面外，还提供了订阅，关注，讨论组，在线编辑器等丰富的功能。 Github被称之为全球最大的基友网站。 3．Git安装3.1.下载安装包，进行安装3.2.默认安装即可，最后的view就不要勾选了 二．Git的使用1．本地仓库1.1. 工作流程 Git本地操作的三个区域-&gt;示意图： 工作流程-&gt;示意图： 1.2.本地仓库操作 什么是仓库呢？仓库又名为版本库，英文名repository，可以简单的理解成是一个目录，用于存放代码，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除等变更状态Git都能跟踪到。 在安装好后首次使用需要进行全局配置,进入Git bash here 进入Git命令行窗口，输入以下命令： Config --global user.name “xxx” 配置用户名 Config --global user.email “xxx” 配置邮箱 在多人协作项目中，用于身份的甄别 创建仓库 当我们需要让Git去管理某个新项目/已存在的项目，就需要创建仓库了。注意，创建仓库的目录不一定要求是空目录，选择一个非空目录也是可以的，但是不建议在现有的项目上来学习Git。 创建空目录 Mkdir file_name 进入目录 Git仓库初始化 Git init 生成git的隐式目录 1.3. \\Git常用指令** 查看当前状态 git status 添加至缓存区 添加一个文件 git add file_name添加多个文件 git add file_1 file_2 file_3添加全部文件 git add . 移除缓存区文件 移出一个文件 git rm -r --cached file_name移出多个文件 git rm -r --cached .移出全部文件 git rm -r --cached .idea 提交至版本库 git commit -m “更新内容描述” 1.4.版本回退 查看版本，确定需要回到的时间点 版本号仅会显示当前，以及当前以前的版本信息 commit bc22b1d47fe55db8901129da1f6c74fdbbddd5b8 (HEAD -&gt; master) 目前版本 获得详细版本状态信息 git log 获得版本提交编号，与注释内容，一行显示 git log --pretty=oneline 回退 git reset --hard 版本号 回退至历史版本后，在回退到当前，则需要查看历史操作，得到想要commit_id git reflog 小结： 回退各个时间段的版本，需获得commit id，进行 git reset –hard commit_id 再次回到当前版本，需要进行reflog直接获得历史操作，以及获得7位commit_id commit_id可以不用输入完整，git会自动识别，但也不能太少，可能会出现重复，至少写前4位字符 1.5. 忽略文件 应用场景 在项目目录下有很多万年不变的文件目录，例如css，js，images等，或者还有一些目录即便有改动，我们也不想让其提交到线上仓库。 实现流程 忽略文件需要新建一个名为.gitignore的规则文件，该文件用于声明忽略文件或不忽略文件的规则，规则对当前目录与子目录生效 注意：该文件没有文件名，没办法直接在windows目录下创建，可以通过命令行创建。 常见规则 过滤整个子目录 /mtk 过滤当前目录与子目录中.zip文件 *.zip 过滤具体文件 /mtk/.doc 不过滤该文件 ! Test.py 创建过滤文件 touch .gitignore 2.远程仓库线上仓库的操作学习以GIthub为例 线上仓库创建，两种常规使用方式 基于http协议 创建空目录，名称就称为WellHome Mkdir WellHome 使用clone指令，克隆线上仓库到本地 git clone source.git 仓库基本操作（提交暂存区，提交本地仓库，提交线上仓库，拉取线上仓库） 提交当线上仓库的指令 git push 若提交后，返回requested 403 因为需要鉴权，则需要权限 需要修改配置文件，在请求url 中添加用户名与密码 拉取线上仓库 git pull 在每天工作的第一件事 git pull 每天下班时做的最后一件事 git push 基于SSH协议 需安装OpenSSH（推荐使用） Https与SSH协议区别：该方式与前面https方式相比，至少影响github对于用户的身份鉴权方式，对于git 的具体操作（如提交本地，添加注释，提交远程等操作）没有任何影响 生成公私钥对指令（需自行安装OpenSSH） ssh-keygen -t rsa -C “注册邮箱”，直接回车继续，返回提示生成的公私钥对的路径 进入提示目录下，找到公钥文件，添加到github中，并编写title clone 仓库 git clone git_ssh地址 — 返回提示yes or no 输入yes即可 分支管理 分支示意图 ​ 在版本回退的操作中，每次提交后都会有记录，Git把它们串成时间线，形成类型时间轴的存在，这个时间轴就是一个分支，我们称为master分支（主分支）。​ 在多人团队协作开发的项目中，一个分支是无法满足多人同时开发的需求的，并且分支上工作并不影响他人正常使用，会更加安全，Git鼓励开发者使用分支去完成开发任务。 分支相关指令 查看分支 git branch 创建分支 git branch 名称 切换分支 git checkout 名称 删除分支 git branch -d 名称 合并分支 git merge 被合并名称 冲突的产生与解决 当线上与本地仓内容不一致时，git会检测出来，并提示让你先pullPull后，git会自动合并代码在改文件中。 解决方法 与变更文件同事沟通，再进行操作 提醒 上班后同步线上代码 图形化管理工具 Github for Desktop Github出品，功能完善，界面简洁，使用方便。 Source tree 老牌Git GUI管理工具，也号称最好用的管理工具，功能丰富，基本操作和高级操作都非常流畅，适合初学者。 TortoiseGit 对于熟悉SVN的开发人员来说，这个小乌龟是非常友善了，简称tgit，中文名海龟Git， 它与前辈TortoiseSVN都是非常优秀的开源版本控制客户端软件。","permalink":"http://yoursite.com/2020/06/30/Git/basic/","photos":[]},{"tags":[{"name":"Basics","slug":"Basics","permalink":"http://yoursite.com/tags/Basics/"}],"title":"basic","date":"2020/06/28","text":"查看库，表，内容 查看MySQL版本号 mysql -V or mysql --version 查看当前所有库 SHOW databases; 进入数据库 USE db_name; 查看当前所有表 SHOW TABLES; SHOW TABLES from db_name; # 查看指定库的表 查看表内容 SELECT * FROM table_name; 创建表，以及字段 CREATE TABLE table_name( Id int(10), # 字段|类型 Name varchar(20)); # 字段|类型 查看所在库 SELECT database(); 查看表结构 DESC table_name; 插入数据 INSERT INTO table_name(id, name) value(1, “mack”); 修改数据 UPDATE table_name SET name=”jack” WHERE id=1; 删除表数据 DELETE FROM table_name WHERE id=1; 基础查询 语法： SELECT field FROM table_name; 特点：查询列表可以是：表中的字段，常量值，表达式，函数 查询表中的单个字段 SELECT field1 FROM table_name; 查询表中多个字段 SELECT field1, field2 from table_name; 查询表中所有字段 SELECT * FROM table_name; 区分关键字与字段 字段名前后加入 ` 符号 查询常量值 SELECT 100; SELECT ‘join’; 查询表达式 SELECT 100*100; 查询函 SELECT version(); 调用version函数返回版本号 赋予别名，改变字段名称 利于理解 如果查询的字段存在重名，使用别名可以进行区分方法一 Select version() as one; 方法二 ``` select version() one; select version() “one pic”; ``` +号的作用 加法运算 SELECT ‘join’ + 100; 输出结果：100 其中一方为字符串，则转换类型，转换失败则置0处理 若一方为Null，则结果为Null DISTINCT-去重 SELECT DICTINCT 字段名 FROM 表名; CONCAT-连接查询字段 SELECT CONCAT(field1, ‘,’ field2) as 列名 FROM table_name; IFNULL-判空函数 SELECT IFNULL(字段名, 0) FROM table_name; 第一个参数为Null，则替换为第二个参数 条件查询 语法 Select 查询字段 from 表名 where 筛选条件; 按条件表达式筛选条件运算符：&gt; &lt; &gt;= &lt;= != &lt;&gt; = 案例1：查询工资&gt;12000的员工信息 SELECT * FROM table_name W salary > 12000; 案例2：查询部分编号!=90的员工名和部门编号 SELECT last_name, first_name, department_id FROM employees WHERE department &lt;> 90; 按逻辑表达式筛选逻辑运算符：And or not 案例1：查询工资在10000到20000之间的员工名，工资，奖金信息 SELECT last_name, salary, commission_pct FROM employees WHERE salary > 10000 AND salary &lt; 20000; 案例2：查询部门编号不是在90到110之间，或者工资高于15000的员工信息 SELECT * FROM employees WHERE department_id > 110 OR department_id &lt; 90 OR salary > 15000; 因为 &gt;110 与 &lt;90条件不冲突，以及salary字段&gt;15000最后才执行 模糊查询关键字：like，between and，in，is null like：一般和通配符配合使用 案例1：查询员工名中包含字符a的员工信息 select * From employees Where last_name like ‘%a%’; 字符串必须使用单引号，%代表通配符，任意字符，包含0个字符 扩展知识Mysql报错1366 解决方案：修改此表的字符集 分别操作：查看表中每个字段的字符集，修改表中的字段的字符集 查看表结构：show full columns from 表名; 改变表结构：alter table 表名 convert to character set utf8; 创建用户和授权在mysql8.0创建用户和授权和之前不太一样了，其实严格上来讲，也不能说是不一样,只能说是更严格,mysql8.0需要先创建用户和设置密码,然后才能授权. 先创建一个用户 create user 'tone'@'%' identified by '123123'; 进行授权 grant all privileges on *.* to 'tone'@'%' with grant option; 如果还是用原来5.7的那种方式，会报错误： grant all privileges on *.* to 'tome'@'%' identified by '123123'; 抛出错误： ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;identified by &#39;123123&#39;&#39; at line 1 MySQL8.0 的远程链接MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题. 登录MySQL mysql -u root -p 输入您的密码，选择 mysql 数据库 use mysql; 因为 mysql 数据库中存储了用户信息的 user 表，在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 select host, user, authentication_string, plugin from user; 执行完上面的命令后会显示一个表格，查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。授权 root 用户的所有权限并设置远程访问 GRANT ALL ON *.* TO 'root'@'%'; GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '你自己的密码'; 刷新权限所有操作后，应执行 flush privileges; 查看 root 用户的 host use mysql; select host, user, authentication_string, plugin from user; 发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。 访问数据库 远程访问数据库的GUI工具比较多如：Navicat、SQLyog、MySQL workbench 等，我这里使用 Navicat 输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.7 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。 出现这个原因是mysql8 之前的版本中加密规则是mysql_native_password,而在mysql8之后,加密规则是caching_sha2_password.解决问题方法有两种,一种是升级navicat驱动,一种是把mysql用户登录密码加密规则还原成mysql_native_password. ​ 这里采用第二种方式 ： ​ 修改加密规则: ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; password 为你当前密码。 ​ 更新 root 用户密码: ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password'; password 为你新设置的密码。 ​ 刷新权限: FLUSH PRIVILEGES; ​ OK，设置完成，再次使用 Navicat 连接数据库","permalink":"http://yoursite.com/2020/06/28/MySQL/basic/","photos":[]}],"categories":[],"tags":[{"name":"InterFace Test","slug":"InterFace-Test","permalink":"http://yoursite.com/tags/InterFace-Test/"},{"name":"Automation InterFace Test","slug":"Automation-InterFace-Test","permalink":"http://yoursite.com/tags/Automation-InterFace-Test/"},{"name":"Basics","slug":"Basics","permalink":"http://yoursite.com/tags/Basics/"}]}